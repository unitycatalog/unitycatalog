package io.unitycatalog.server.persist.dao;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.unitycatalog.server.exception.BaseException;
import io.unitycatalog.server.exception.ErrorCode;
import io.unitycatalog.server.model.AwsIamRoleRequest;
import io.unitycatalog.server.model.AwsIamRoleResponse;
import io.unitycatalog.server.model.CreateCredentialRequest;
import io.unitycatalog.server.model.CredentialInfo;
import io.unitycatalog.server.model.CredentialPurpose;
import io.unitycatalog.server.utils.ServerProperties;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Lob;
import jakarta.persistence.Table;
import java.util.Date;
import java.util.Optional;
import java.util.UUID;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;
import software.amazon.awssdk.services.sts.model.AssumeRoleRequest;

/**
 * Data Access Object for storing cloud provider credentials in Unity Catalog.
 *
 * <p>This DAO persists credentials used to access cloud storage (S3, ADLS, GCS) for external
 * locations and storage credentials. The credential payload is stored as a JSON blob in the {@code
 * credential} column, with the {@code credentialType} discriminator indicating how to deserialize
 * it.
 *
 * <h2>Supported Cloud Providers</h2>
 *
 * <ul>
 *   <li><b>AWS</b> - IAM Role-based credentials
 *   <li><b>Azure</b> - Not implemented yet.
 *   <li><b>GCP</b> - Not implemented yet.
 * </ul>
 *
 * <h2>For AWS, it stores {@link AwsIamRoleResponse}:</h2>
 *
 * <ul>
 *   <li>{@code role_arn} - Customer-provided data IAM role ARN that has permissions to access
 *       storage. Populated from {@link AwsIamRoleRequest}. Will be assumed by the master IAM role.
 *   <li>{@code unity_catalog_iam_arn} - The ARN of Unity Catalog's <b>master</b> IAM role. The
 *       customer must add this ARN to the trust policy of their data role. This value comes from
 *       server configuration ({@link ServerProperties.Property#AWS_MASTER_ROLE_ARN}). It will
 *       assume {@code role_arn} to generate an access token on behalf of {@code role_arn}.
 *   <li>{@code external_id} - A unique UUID generated by Unity Catalog for this credential. Used in
 *       the role assumption call to prevent the "confused deputy" security problem. The customer
 *       must include this external ID in their role's trust policy condition. See {@link
 *       AssumeRoleRequest#externalId()}
 * </ul>
 *
 * @see AwsIamRoleRequest
 * @see AwsIamRoleResponse
 */
@Entity
@Table(name = "uc_credentials")
// Lombok
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class CredentialDAO extends IdentifiableDAO {
  private static ObjectMapper objectMapper = new ObjectMapper();

  public enum CredentialType {
    AWS_IAM_ROLE,
    // Add other types as necessary
  }

  @Column(name = "credential_type", nullable = false)
  @Enumerated(EnumType.STRING)
  // No direct setter from outside
  @Setter(AccessLevel.NONE)
  private CredentialType credentialType;

  @Lob
  @Column(name = "credential", nullable = false)
  // No direct access from outside
  @Getter(AccessLevel.NONE)
  @Setter(AccessLevel.NONE)
  private String credential;

  @Column(name = "purpose", nullable = false)
  private CredentialPurpose purpose;

  @Column(name = "comment")
  private String comment;

  @Column(name = "owner")
  private String owner;

  @Column(name = "created_at", nullable = false)
  private Date createdAt;

  @Column(name = "created_by")
  private String createdBy;

  @Column(name = "updated_at")
  private Date updatedAt;

  @Column(name = "updated_by")
  private String updatedBy;

  public static CredentialDAO from(CreateCredentialRequest createRequest, String callerId) {
    Date now = new Date();
    CredentialDAO dao =
        CredentialDAO.builder()
            .id(UUID.randomUUID())
            .name(createRequest.getName())
            .purpose(createRequest.getPurpose())
            .comment(createRequest.getComment())
            .owner(callerId)
            .createdAt(now)
            .createdBy(callerId)
            .updatedAt(now)
            .updatedBy(callerId)
            .build();
    if (createRequest.getAwsIamRole() != null) {
      dao.setAwsIamRole(createRequest.getAwsIamRole());
    } else {
      throw new IllegalArgumentException("Unknown credential type");
    }
    return dao;
  }

  public CredentialInfo toCredentialInfo(Optional<String> masterAwsIamRoleArn) {
    CredentialInfo credentialInfo =
        new CredentialInfo()
            .id(getId().toString())
            .name(getName())
            .purpose(purpose)
            .comment(comment)
            .owner(owner)
            .createdAt(createdAt.getTime())
            .createdBy(createdBy)
            .updatedAt(updatedAt != null ? updatedAt.getTime() : null)
            .updatedBy(updatedBy);
    switch (credentialType) {
      case AWS_IAM_ROLE:
        AwsIamRoleResponse awsIamRole = parseCredential(AwsIamRoleResponse.class);
        masterAwsIamRoleArn.ifPresent(awsIamRole::setUnityCatalogIamArn);
        credentialInfo.setAwsIamRole(awsIamRole);
        break;
        // TODO: support Azure and GCP.
      default:
        throw new IllegalArgumentException("Unknown credential type: " + credentialType);
    }
    return credentialInfo;
  }

  private <T> T parseCredential(CredentialType credentialType, Class<T> clazz) {
    if (getCredentialType() != credentialType) {
      // Mismatch credential type.
      throw new BaseException(
          ErrorCode.FAILED_PRECONDITION,
          String.format("Storage credential '%s' is not %s.", getName(), credentialType));
    }
    return parseCredential(clazz);
  }

  private <T> T parseCredential(Class<T> clazz) {
    try {
      return objectMapper.readValue(credential, clazz);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(
          "Failed to parse credential of " + clazz.getSimpleName(), e);
    }
  }

  public void setAwsIamRole(AwsIamRoleRequest awsIamRole) {
    setCredential(CredentialType.AWS_IAM_ROLE, fromAwsIamRoleRequest(awsIamRole));
  }

  private <T> void setCredential(CredentialType type, T inputCredential) {
    credentialType = type;
    try {
      credential = objectMapper.writeValueAsString(inputCredential);
      // TODO: encrypt the credential
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(
          "Failed to parse credential of " + credential.getClass().getSimpleName(), e);
    }
  }

  private static AwsIamRoleResponse fromAwsIamRoleRequest(AwsIamRoleRequest awsIamRoleRequest) {
    return new AwsIamRoleResponse()
        .roleArn(awsIamRoleRequest.getRoleArn())
        .externalId(UUID.randomUUID().toString());
  }

  public AwsIamRoleResponse getAwsIamRoleResponse() {
    return parseCredential(CredentialType.AWS_IAM_ROLE, AwsIamRoleResponse.class);
  }
}
