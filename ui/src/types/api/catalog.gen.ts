/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/catalogs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List catalogs
     * @description Lists the available catalogs. There is no guarantee of a specific ordering of the elements in the list.
     *
     */
    get: operations['listCatalogs'];
    put?: never;
    /**
     * Create a catalog
     * @description Creates a new catalog instance.
     *
     */
    post: operations['createCatalog'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/catalogs/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the catalog. */
        name: string;
      };
      cookie?: never;
    };
    /**
     * Get a catalog
     * @description Gets the specified catalog.
     *
     */
    get: operations['getCatalog'];
    put?: never;
    post?: never;
    /**
     * Delete a catalog
     * @description Deletes the catalog that matches the supplied name.
     *
     */
    delete: operations['deleteCatalog'];
    options?: never;
    head?: never;
    /**
     * Update a catalog
     * @description Updates the catalog that matches the supplied name.
     *
     */
    patch: operations['updateCatalog'];
    trace?: never;
  };
  '/schemas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List schemas
     * @description Gets an array of schemas for a catalog.
     *     There is no guarantee of a specific ordering of the elements in the array.
     *
     */
    get: operations['listSchemas'];
    put?: never;
    /**
     * Create a schema
     * @description Creates a new schema in the specified catalog.
     *
     */
    post: operations['createSchema'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/schemas/{full_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the schema. */
        full_name: string;
      };
      cookie?: never;
    };
    /**
     * Get a schema
     * @description Gets the specified schema for a catalog.
     *
     */
    get: operations['getSchema'];
    put?: never;
    post?: never;
    /**
     * Delete a schema
     * @description Deletes the specified schema from the parent catalog.
     *
     */
    delete: operations['deleteSchema'];
    options?: never;
    head?: never;
    /**
     * Update a schema
     * @description Updates the specified schema.
     *
     */
    patch: operations['updateSchema'];
    trace?: never;
  };
  '/tables': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List tables
     * @description Gets the list of all available tables under the parent catalog and schema.
     *     There is no guarantee of a specific ordering of the elements in the array.
     *
     */
    get: operations['listTables'];
    put?: never;
    /**
     * Create a table. Only external table creation is supported.
     *     WARNING: This API is experimental and will change in future versions.
     *
     * @description Creates a new external table instance.
     *     WARNING: This API is experimental and will change in future versions.
     *
     */
    post: operations['createTable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/tables/{full_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the table. */
        full_name: string;
      };
      cookie?: never;
    };
    /**
     * Get a table
     * @description Gets a table for a specific catalog and schema.
     *
     */
    get: operations['getTable'];
    put?: never;
    post?: never;
    /**
     * Delete a table
     * @description Deletes a table from the specified parent catalog and schema.
     *
     */
    delete: operations['deleteTable'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/volumes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Volumes
     * @description Gets an array of available volumes under the parent catalog and schema.
     *     There is no guarantee of a specific ordering of the elements in the array.
     *
     */
    get: operations['listVolumes'];
    put?: never;
    /**
     * Create a Volume
     * @description Creates a new volume.
     *
     */
    post: operations['createVolume'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/volumes/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The three-level (fully qualified) name of the volume */
        name: string;
      };
      cookie?: never;
    };
    /**
     * Get a Volume
     * @description Gets a volume for a specific catalog and schema.
     *
     */
    get: operations['getVolume'];
    put?: never;
    post?: never;
    /**
     * Delete a Volume
     * @description Deletes a volume from the specified parent catalog and schema.
     *
     */
    delete: operations['deleteVolume'];
    options?: never;
    head?: never;
    /**
     * Update a Volume
     * @description Updates the specified volume under the specified parent catalog and schema.
     *
     *     Currently only the name or the comment of the volume could be updated.
     *
     */
    patch: operations['updateVolume'];
    trace?: never;
  };
  '/temporary-model-version-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate temporary model version credentials. These credentials are used by clients to write and retrieve model artifacts from the model versions external storage location. */
    post: operations['generateTemporaryModelVersionCredentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/temporary-table-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate temporary table credentials. */
    post: operations['generateTemporaryTableCredentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/temporary-volume-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate temporary volume credentials. */
    post: operations['generateTemporaryVolumeCredentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/functions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List functions
     * @description List functions within the specified parent catalog and schema.
     *     There is no guarantee of a specific ordering of the elements in the array.
     *
     */
    get: operations['listFunctions'];
    put?: never;
    /**
     * Create a function.
     *     WARNING: This API is experimental and will change in future versions.
     *
     * @description Creates a new function instance.
     *     WARNING: This API is experimental and will change in future versions.
     *
     */
    post: operations['createFunction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/functions/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). */
        name: string;
      };
      cookie?: never;
    };
    /**
     * Get a function
     * @description Gets a function from within a parent catalog and schema.
     */
    get: operations['getFunction'];
    put?: never;
    post?: never;
    /**
     * Delete a function
     * @description Deletes the function that matches the supplied name.
     */
    delete: operations['deleteFunction'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/models': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List models
     * @description Gets a paginated list of all available models either under the specified parent catalog and schema, or all models stored in UC.
     *     There is no guarantee of a specific ordering of the elements in the array.
     *
     */
    get: operations['listRegisteredModels'];
    put?: never;
    /**
     * Create a model.
     *     WARNING: This API is experimental and will change in future versions.
     *
     * @description Creates a new model instance.
     *     WARNING: This API is experimental and will change in future versions.
     *
     */
    post: operations['createRegisteredModel'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/models/{full_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
      };
      cookie?: never;
    };
    /**
     * Get a specified registered model
     * @description Gets a fully specified registered model.
     *
     */
    get: operations['getRegisteredModel'];
    put?: never;
    post?: never;
    /**
     * Delete a specified registered model.
     * @description Deletes a fully specified registered model. All versions of the model must have already been deleted.
     *
     */
    delete: operations['deleteRegisteredModel'];
    options?: never;
    head?: never;
    /**
     * Update a registered model
     * @description Updates the specified registered model.
     *
     */
    patch: operations['updateRegisteredModel'];
    trace?: never;
  };
  '/models/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a model version.
     *
     * @description Creates a new model version instance.
     *
     */
    post: operations['createModelVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/models/{full_name}/versions': {
    parameters: {
      query?: {
        /** @description Maximum number of model versions to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
        /** @description Opaque token to send for the next page of results (pagination). */
        page_token?: string;
      };
      header?: never;
      path: {
        /** @description Full name of the registered model. */
        full_name: string;
      };
      cookie?: never;
    };
    /**
     * List model versions of the specified registered model.
     * @description Gets the paginated list of all available model versions under the specified registered model.
     *     There is no guarantee of a specific ordering of the elements in the array.
     *
     */
    get: operations['listModelVersions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/models/{full_name}/versions/{version}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
        /** @description Version number of the model version. */
        version: number;
      };
      cookie?: never;
    };
    /**
     * Get a model version
     * @description Gets a specific model version for a specific model.
     *
     */
    get: operations['getModelVersion'];
    put?: never;
    post?: never;
    /**
     * Delete a model version
     * @description Deletes the specified model version.
     *
     */
    delete: operations['deleteModelVersion'];
    options?: never;
    head?: never;
    /**
     * Update a model version
     * @description Updates the specified model version.
     *
     */
    patch: operations['updateModelVersion'];
    trace?: never;
  };
  '/models/{full_name}/versions/{version}/finalize': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
        /** @description Version number of the model version. */
        version: number;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Finalize a model version
     * @description Finalizes the status of the specified model version.
     *
     */
    patch: operations['finalizeModelVersion'];
    trace?: never;
  };
  '/temporary-path-credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate temporary path credentials. */
    post: operations['generateTemporaryPathCredentials'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permissions/{securable_type}/{full_name}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Type of securable. */
        securable_type: components['schemas']['SecurableType'];
        /** @description Full name of securable. */
        full_name: string;
      };
      cookie?: never;
    };
    /**
     * Get permissions
     * @description Gets the permissions for a securable.
     *
     */
    get: operations['get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a permission
     * @description Updates the permissions for a securable.
     *
     */
    patch: operations['update'];
    trace?: never;
  };
  '/metastore_summary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get metastore summary
     * @description Gets information about the metastore hosted by this Unity Catalog service (currently the service hosts only one metastore)
     *
     */
    get: operations['summary'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description A map of key-value properties attached to the securable. */
    SecurablePropertiesMap: {
      [key: string]: string;
    };
    /**
     * @description The type of the volume
     * @enum {string}
     */
    VolumeType: VolumeType;
    CreateVolumeRequestContent: {
      /** @description The name of the catalog where the schema and the volume are */
      catalog_name: string;
      /** @description The name of the schema where the volume is */
      schema_name: string;
      /** @description The name of the volume */
      name: string;
      volume_type: components['schemas']['VolumeType'];
      /** @description The comment attached to the volume */
      comment?: string;
      /** @description The storage location of the volume */
      storage_location: string;
    };
    ListVolumesResponseContent: {
      volumes?: components['schemas']['VolumeInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request to retrieve the next page of results.
       *      */
      next_page_token?: string;
    };
    UpdateVolumeRequestContent: {
      /** @description The comment attached to the volume */
      comment?: string;
      /** @description New name for the volume. */
      new_name?: string;
    };
    VolumeInfo: {
      /** @description The name of the catalog where the schema and the volume are */
      catalog_name?: string;
      /** @description The name of the schema where the volume is */
      schema_name?: string;
      /** @description The name of the volume */
      name?: string;
      /** @description The comment attached to the volume */
      comment?: string;
      /** @description The identifier of the user who owns the volume */
      owner?: string;
      /**
       * Format: int64
       * @description Time at which this volume was created, in epoch milliseconds.
       */
      created_at?: number;
      /** @description TThe identifier of the user who created the volume */
      created_by?: string;
      /**
       * Format: int64
       * @description Time at which this volume was last modified, in epoch milliseconds.
       */
      updated_at?: number;
      /** @description The identifier of the user who updated the volume last time */
      updated_by?: string;
      /** @description Unique identifier of the volume */
      volume_id?: string;
      volume_type?: components['schemas']['VolumeType'];
      /** @description The storage location of the volume */
      storage_location?: string;
      /** @description Full name of volume, in form of __catalog_name__.__schema_name__.__volume_name__. */
      full_name?: string;
    };
    /**
     * @description Name of type (INT, STRUCT, MAP, etc.).
     * @enum {string}
     */
    ColumnTypeName: ColumnTypeName;
    ColumnInfo: {
      /** @description Name of Column. */
      name?: string;
      /** @description Full data type specification as SQL/catalogString text. */
      type_text?: string;
      /** @description Full data type specification, JSON-serialized. */
      type_json?: string;
      type_name?: components['schemas']['ColumnTypeName'];
      /**
       * Format: int32
       * @description Digits of precision; required for DecimalTypes.
       */
      type_precision?: number;
      /**
       * Format: int32
       * @description Digits to right of decimal; Required for DecimalTypes.
       */
      type_scale?: number;
      /** @description Format of IntervalType. */
      type_interval_type?: string;
      /**
       * Format: int32
       * @description Ordinal position of column (starting at position 0).
       */
      position?: number;
      /** @description User-provided free-form text description. */
      comment?: string;
      /**
       * @description Whether field may be Null.
       * @default true
       */
      nullable: boolean;
      /**
       * Format: int32
       * @description Partition index for column.
       */
      partition_index?: number;
    };
    /** @enum {string} */
    TableType: TableType;
    /**
     * @description Data source format
     * @enum {string}
     */
    DataSourceFormat: DataSourceFormat;
    TableInfo: {
      /** @description Name of table, relative to parent schema. */
      name?: string;
      /** @description Name of parent catalog. */
      catalog_name?: string;
      /** @description Name of parent schema relative to its parent catalog. */
      schema_name?: string;
      table_type?: components['schemas']['TableType'];
      data_source_format?: components['schemas']['DataSourceFormat'];
      /** @description The array of __ColumnInfo__ definitions of the table's columns. */
      columns?: components['schemas']['ColumnInfo'][];
      /** @description Storage root URL for table (for **MANAGED**, **EXTERNAL** tables) */
      storage_location?: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
      /** @description Username of current owner of table. */
      owner?: string;
      /**
       * Format: int64
       * @description Time at which this table was created, in epoch milliseconds.
       */
      created_at?: number;
      /** @description Username of table creator. */
      created_by?: string;
      /**
       * Format: int64
       * @description Time at which this table was last modified, in epoch milliseconds.
       */
      updated_at?: number;
      /** @description Username of user who last modified the table. */
      updated_by?: string;
      /** @description Unique identifier for the table. */
      table_id?: string;
    };
    CreateTable: {
      /** @description Name of table, relative to parent schema. */
      name: string;
      /** @description Name of parent catalog. */
      catalog_name: string;
      /** @description Name of parent schema relative to its parent catalog. */
      schema_name: string;
      table_type: components['schemas']['TableType'];
      data_source_format: components['schemas']['DataSourceFormat'];
      /** @description The array of __ColumnInfo__ definitions of the table's columns. */
      columns: components['schemas']['ColumnInfo'][];
      /** @description Storage root URL for external table */
      storage_location: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
    };
    ListTablesResponse: {
      /** @description An array of table information objects. */
      tables?: components['schemas']['TableInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request (for the next page of results).
       *      */
      next_page_token?: string;
    };
    SchemaInfo: {
      /** @description Name of schema, relative to parent catalog. */
      name?: string;
      /** @description Name of parent catalog. */
      catalog_name?: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
      /** @description Full name of schema, in form of __catalog_name__.__schema_name__. */
      full_name?: string;
      /** @description Username of current owner of schema. */
      owner?: string;
      /**
       * Format: int64
       * @description Time at which this schema was created, in epoch milliseconds.
       */
      created_at?: number;
      /** @description Username of schema creator. */
      created_by?: string;
      /**
       * Format: int64
       * @description Time at which this schema was last modified, in epoch milliseconds.
       */
      updated_at?: number;
      /** @description Username of user who last modified schema. */
      updated_by?: string;
      /** @description Unique identifier for the schema. */
      schema_id?: string;
    };
    CreateSchema: {
      /** @description Name of schema, relative to parent catalog. */
      name: string;
      /** @description Name of parent catalog. */
      catalog_name: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
    };
    UpdateSchema: {
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
      /** @description New name for the schema. */
      new_name?: string;
    };
    ListSchemasResponse: {
      /** @description An array of schema information objects. */
      schemas?: components['schemas']['SchemaInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request (for the next page of results).
       *      */
      next_page_token?: string;
    };
    CatalogInfo: {
      /** @description Name of catalog. */
      name?: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
      /** @description Username of current owner of catalog. */
      owner?: string;
      /**
       * Format: int64
       * @description Time at which this catalog was created, in epoch milliseconds.
       */
      created_at?: number;
      /** @description Username of catalog creator. */
      created_by?: string;
      /**
       * Format: int64
       * @description Time at which this catalog was last modified, in epoch milliseconds.
       */
      updated_at?: number;
      /** @description Username of user who last modified catalog. */
      updated_by?: string;
      /** @description Unique identifier for the catalog. */
      id?: string;
    };
    CreateCatalog: {
      /** @description Name of catalog. */
      name: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
    };
    UpdateCatalog: {
      /** @description User-provided free-form text description. */
      comment?: string;
      properties?: components['schemas']['SecurablePropertiesMap'];
      /** @description New name for the catalog. */
      new_name?: string;
    };
    ListCatalogsResponse: {
      /** @description An array of catalog information objects. */
      catalogs?: components['schemas']['CatalogInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request (for the next page of results).
       *      */
      next_page_token?: string;
    };
    /**
     * @description The type of function parameter.
     * @enum {string}
     */
    FunctionParameterType: FunctionParameterType;
    /**
     * @description The mode of the function parameter.
     * @enum {string}
     */
    FunctionParameterMode: FunctionParameterMode;
    FunctionParameterInfo: {
      /** @description Name of parameter. */
      name: string;
      /** @description Full data type spec, SQL/catalogString text. */
      type_text: string;
      /** @description Full data type spec, JSON-serialized. */
      type_json: string;
      type_name: components['schemas']['ColumnTypeName'];
      /**
       * Format: int32
       * @description Digits of precision; required on Create for DecimalTypes.
       */
      type_precision?: number;
      /**
       * Format: int32
       * @description Digits to right of decimal; Required on Create for DecimalTypes.
       */
      type_scale?: number;
      /** @description Format of IntervalType. */
      type_interval_type?: string;
      /**
       * Format: int32
       * @description Ordinal position of column (starting at position 0).
       */
      position: number;
      parameter_mode?: components['schemas']['FunctionParameterMode'];
      parameter_type?: components['schemas']['FunctionParameterType'];
      /** @description Default value of the parameter. */
      parameter_default?: string;
      /** @description User-provided free-form text description. */
      comment?: string;
    };
    FunctionParameterInfos: {
      /** @description The array of __FunctionParameterInfo__ definitions of the function's parameters. */
      parameters?: components['schemas']['FunctionParameterInfo'][];
    };
    CreateFunctionRequest: {
      function_info: components['schemas']['CreateFunction'];
    };
    /** @description A function that is dependent on a SQL object. */
    FunctionDependency: {
      /** @description Full name of the dependent function, in the form of __catalog_name__.__schema_name__.__function_name__. */
      function_full_name: string;
    };
    /** @description A table that is dependent on a SQL object. */
    TableDependency: {
      /** @description Full name of the dependent table, in the form of __catalog_name__.__schema_name__.__table_name__. */
      table_full_name: string;
    };
    /** @description A dependency of a SQL object. Either the __table__ field or the __function__ field must be defined. */
    Dependency: {
      table?: components['schemas']['TableDependency'];
      function?: components['schemas']['FunctionDependency'];
    };
    /** @description A list of dependencies. */
    DependencyList: {
      /** @description Array of dependencies. */
      dependencies?: components['schemas']['Dependency'][];
    };
    CreateFunction: {
      /** @description Name of function, relative to parent schema. */
      name: string;
      /** @description Name of parent catalog. */
      catalog_name: string;
      /** @description Name of parent schema relative to its parent catalog. */
      schema_name: string;
      input_params: components['schemas']['FunctionParameterInfos'];
      data_type: components['schemas']['ColumnTypeName'];
      /** @description Pretty printed function data type. */
      full_data_type: string;
      return_params?: components['schemas']['FunctionParameterInfos'];
      /**
       * @description Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,
       *     and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported),
       *     and the __sql_data_access__ field must be **NO_SQL**.
       *
       * @enum {string}
       */
      routine_body: CreateFunctionRoutine_body;
      /** @description Function body. */
      routine_definition: string;
      routine_dependencies?: components['schemas']['DependencyList'];
      /**
       * @description Function parameter style. **S** is the value for SQL.
       * @enum {string}
       */
      parameter_style: CreateFunctionParameter_style;
      /** @description Whether the function is deterministic. */
      is_deterministic: boolean;
      /**
       * @description Function SQL data access.
       * @enum {string}
       */
      sql_data_access: CreateFunctionSql_data_access;
      /** @description Function null call. */
      is_null_call: boolean;
      /**
       * @description Function security type.
       * @enum {string}
       */
      security_type: CreateFunctionSecurity_type;
      /** @description Specific name of the function; Reserved for future use. */
      specific_name: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      /** @description JSON-serialized key-value pair map, encoded (escaped) as a string. */
      properties: string;
      /** @description External language of the function. */
      external_language?: string;
    };
    FunctionInfo: {
      /** @description Name of function, relative to parent schema. */
      name?: string;
      /** @description Name of parent catalog. */
      catalog_name?: string;
      /** @description Name of parent schema relative to its parent catalog. */
      schema_name?: string;
      input_params?: components['schemas']['FunctionParameterInfos'];
      data_type?: components['schemas']['ColumnTypeName'];
      /** @description Pretty printed function data type. */
      full_data_type?: string;
      return_params?: components['schemas']['FunctionParameterInfos'];
      /**
       * @description Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,
       *     and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported),
       *     and the __sql_data_access__ field must be **NO_SQL**.
       *
       * @enum {string}
       */
      routine_body?: FunctionInfoRoutine_body;
      /** @description Function body. */
      routine_definition?: string;
      routine_dependencies?: components['schemas']['DependencyList'];
      /**
       * @description Function parameter style. **S** is the value for SQL.
       * @enum {string}
       */
      parameter_style?: FunctionInfoParameter_style;
      /** @description Whether the function is deterministic. */
      is_deterministic?: boolean;
      /**
       * @description Function SQL data access.
       * @enum {string}
       */
      sql_data_access?: FunctionInfoSql_data_access;
      /** @description Function null call. */
      is_null_call?: boolean;
      /**
       * @description Function security type.
       * @enum {string}
       */
      security_type?: FunctionInfoSecurity_type;
      /** @description Specific name of the function; Reserved for future use. */
      specific_name?: string;
      /** @description User-provided free-form text description. */
      comment?: string;
      /** @description JSON-serialized key-value pair map, encoded (escaped) as a string. */
      properties?: string;
      /** @description Full name of function, in form of __catalog_name__.__schema_name__.__function__name__ */
      full_name?: string;
      /** @description Username of current owner of function. */
      owner?: string;
      /**
       * Format: int64
       * @description Time at which this function was created, in epoch milliseconds.
       */
      created_at?: number;
      /** @description Username of function creator. */
      created_by?: string;
      /**
       * Format: int64
       * @description Time at which this function was last updated, in epoch milliseconds.
       */
      updated_at?: number;
      /** @description Username of user who last modified function. */
      updated_by?: string;
      /** @description Id of Function, relative to parent schema. */
      function_id?: string;
      /** @description External language of the function. */
      external_language?: string;
    };
    ListFunctionsResponse: {
      /** @description An array of function information objects. */
      functions?: components['schemas']['FunctionInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request (for the next page of results).
       *      */
      next_page_token?: string;
    };
    /** @example {
     *       "catalog_name": "catalog_name",
     *       "schema_name": "schema_name",
     *       "model_name": "model_name",
     *       "version": "version",
     *       "operation": null
     *     } */
    GenerateTemporaryModelVersionCredential: {
      /** @description Catalog name for which temporary credentials are generated.
       *     Can be obtained from models/{full_name} (get model info) API.
       *      */
      catalog_name: string;
      /** @description Schema name for which temporary credentials are generated.
       *     Can be obtained from models/{full_name} (get model info) API.
       *      */
      schema_name: string;
      /** @description Model name for which temporary credentials are generated.
       *     Can be obtained from models/{full_name} (get model info) API.
       *      */
      model_name: string;
      /**
       * Format: int64
       * @description Model version for which temporary credentials are generated.
       *
       */
      version: number;
      operation: components['schemas']['ModelVersionOperation'];
    };
    /** @enum {string} */
    ModelVersionOperation: ModelVersionOperation;
    /** @example {
     *       "table_id": "table_id",
     *       "operation": null
     *     } */
    GenerateTemporaryTableCredential: {
      /** @description Table id for which temporary credentials are generated.
       *     Can be obtained from tables/{full_name} (get table info) API.
       *      */
      table_id: string;
      operation: components['schemas']['TableOperation'];
    };
    /** @enum {string} */
    TableOperation: TableOperation;
    AwsCredentials: {
      /** @description The access key ID that identifies the temporary credentials. */
      access_key_id?: string;
      /** @description The secret access key that can be used to sign AWS API requests. */
      secret_access_key?: string;
      /** @description The token that users must pass to AWS API to use the temporary credentials. */
      session_token?: string;
    };
    AzureUserDelegationSAS: {
      /** @description Azure SAS Token */
      sas_token?: string;
    };
    GcpOauthToken: {
      /** @description Gcp Token */
      oauth_token?: string;
    };
    GenerateTemporaryVolumeCredential: {
      /** @description Volume id for which temporary credentials are generated.
       *     Can be obtained from volumes/{full_name} (get volume info) API.
       *      */
      volume_id: string;
      operation: components['schemas']['VolumeOperation'];
    };
    /** @enum {string} */
    VolumeOperation: VolumeOperation;
    RegisteredModelInfo: {
      /** @description The name of the registered model */
      name?: string;
      /** @description The name of the catalog where the schema and the registered model reside */
      catalog_name?: string;
      /** @description The name of the schema where the registered model resides */
      schema_name?: string;
      /** @description The storage location on the cloud under which model version data files are stored */
      storage_location?: string;
      /** @description The three-level (fully qualified) name of the registered model */
      full_name?: string;
      /** @description The comment attached to the registered model */
      comment?: string;
      /** @description The identifier of the user who owns the registered model */
      owner?: string;
      /**
       * Format: int64
       * @description Creation timestamp of the registered model in milliseconds since the Unix epoch
       */
      created_at?: number;
      /** @description The identifier of the user who created the registered model */
      created_by?: string;
      /**
       * Format: int64
       * @description Last-update timestamp of the registered model in milliseconds since the Unix epoch
       */
      updated_at?: number;
      /** @description The identifier of the user who updated the registered model last time */
      updated_by?: string;
      /** @description Unique identifier for the registered model. */
      id?: string;
    };
    ModelVersionInfo: {
      /** @description The name of the parent registered model of the model version, relative to parent schema */
      model_name?: string;
      /** @description The name of the catalog containing the model version */
      catalog_name?: string;
      /** @description The name of the schema containing the model version, relative to parent catalog */
      schema_name?: string;
      /**
       * Format: int64
       * @description Integer model version number, used to reference the model version in API requests.
       */
      version?: number;
      /** @description URI indicating the location of the source artifacts (files) for the model version */
      source?: string;
      /** @description The run id used by the ML package that generated the model. */
      run_id?: string;
      status?: components['schemas']['ModelVersionStatus'];
      /** @description The storage location on the cloud under which model version data files are stored */
      storage_location?: string;
      /** @description The comment attached to the model version */
      comment?: string;
      /**
       * Format: int64
       * @description Time at which this model version was created, in epoch milliseconds.
       */
      created_at?: number;
      /** @description The identifier of the user who created the model version */
      created_by?: string;
      /**
       * Format: int64
       * @description Time at which this model version was last modified, in epoch milliseconds.
       */
      updated_at?: number;
      /** @description The identifier of the user who updated the model version last time */
      updated_by?: string;
      /** @description Unique identifier for the model version. */
      id?: string;
    };
    /**
     * @description All possible model version statuses (MODEL_VERSION_STATUS_UNKNOWN, PENDING_REGISTRATION, FAILED_REGISTRATION, READY).
     *     PENDING_REGISTRATION status indicates that the client has not completely written all model artifacts to external storage.
     *     FAILED_REGISTRATION status indicates that the client has failed to write all model artifacts to external storage.
     *     READY status indicates that the client has successfully written all model artifacts to external storage.
     *
     * @enum {string}
     */
    ModelVersionStatus: ModelVersionStatus;
    CreateRegisteredModel: {
      /** @description Name of model, relative to parent schema. */
      name: string;
      /** @description Name of parent catalog. */
      catalog_name: string;
      /** @description Name of parent schema relative to its parent catalog. */
      schema_name: string;
      /** @description User-provided free-form text description. */
      comment?: string;
    };
    UpdateRegisteredModel: {
      /** @description User-provided free-form text description. */
      comment?: string;
      /** @description New name for the model. */
      new_name?: string;
    };
    ListRegisteredModelsResponse: {
      /** @description An array of model information objects. */
      registered_models?: components['schemas']['RegisteredModelInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request (for the next page of results).
       *      */
      next_page_token?: string;
    };
    CreateModelVersion: {
      /** @description Name of registered model, relative to parent schema. */
      model_name: string;
      /** @description Name of parent catalog. */
      catalog_name: string;
      /** @description Name of parent schema relative to its parent catalog. */
      schema_name: string;
      /** @description URI indicating the location of the source model artifacts. */
      source: string;
      /** @description The run id used by the ML package that generated the model. */
      run_id?: string;
      /** @description User-provided free-form text description. */
      comment?: string;
    };
    UpdateModelVersion: {
      /** @description User-provided free-form text description. */
      comment?: string;
    };
    ListModelVersionsResponse: {
      /** @description An array of model version information objects. */
      model_versions?: components['schemas']['ModelVersionInfo'][];
      /** @description Opaque token to retrieve the next page of results. Absent if there are no more pages.
       *     __page_token__ should be set to this value for the next request (for the next page of results).
       *      */
      next_page_token?: string;
    };
    FinalizeModelVersion: {
      /** @description The full name of the registered model to finalize. */
      full_name: string;
      /**
       * Format: int64
       * @description Version number of the version to finalize.
       */
      version: number;
    };
    GenerateTemporaryPathCredential: {
      /** @description The URL of the storage path for which temporary credentials need to be generated. */
      url: string;
      operation: components['schemas']['PathOperation'];
    };
    TemporaryCredentials: {
      aws_temp_credentials?: components['schemas']['AwsCredentials'];
      azure_user_delegation_sas?: components['schemas']['AzureUserDelegationSAS'];
      gcp_oauth_token?: components['schemas']['GcpOauthToken'];
      /**
       * Format: int64
       * @description Server time when the credential will expire, in epoch milliseconds.
       *     The API client is advised to cache the credential given this expiration time.
       *
       */
      expiration_time?: number;
    };
    /** @enum {string} */
    PathOperation: PathOperation;
    /**
     * @description The type of the principal.
     * @enum {string}
     */
    PrincipalType: PrincipalType;
    /**
     * @description The type of the resource.
     * @enum {string}
     */
    SecurableType: SecurableType;
    /**
     * @description The privilege to grant.
     * @enum {string}
     */
    Privilege: Privilege;
    UpdatePermissions: {
      /** @description Array of permissions change objects. */
      changes: components['schemas']['PermissionsChange'][];
    };
    PermissionsChange: {
      /** @description The principal whose privileges we are changing. */
      principal: string;
      /** @description The set of privileges to add. */
      add: components['schemas']['Privilege'][];
      /** @description The set of privileges to remove. */
      remove: components['schemas']['Privilege'][];
    };
    PermissionsList: {
      /** @description The privileges assigned to each principal. */
      privilege_assignments: components['schemas']['PrivilegeAssignment'][];
    };
    PrivilegeAssignment: {
      /** @description The principal (user email address or group name). */
      principal: string;
      /** @description The privileges assigned to the principal. */
      privileges: components['schemas']['Privilege'][];
    };
    GetMetastoreSummaryResponse: {
      /** @description Unique identifier of the metastore. */
      metastore_id?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  listCatalogs: {
    parameters: {
      query?: {
        /** @description Opaque pagination token to go to next page based on previous query.
         *      */
        page_token?: string;
        /** @description Maximum number of catalogs to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The catalog list was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCatalogsResponse'];
        };
      };
    };
  };
  createCatalog: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateCatalog'];
      };
    };
    responses: {
      /** @description The new catalog was successfully created. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CatalogInfo'];
        };
      };
    };
  };
  getCatalog: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the catalog. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The catalog was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CatalogInfo'];
        };
      };
    };
  };
  deleteCatalog: {
    parameters: {
      query?: {
        /** @description Force deletion even if the catalog is not empty. */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description The name of the catalog. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The catalog was successfully deleted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  updateCatalog: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the catalog. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateCatalog'];
      };
    };
    responses: {
      /** @description The catalog was successfully updated. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CatalogInfo'];
        };
      };
    };
  };
  listSchemas: {
    parameters: {
      query: {
        /** @description Parent catalog for schemas of interest. */
        catalog_name: string;
        /** @description Maximum number of schemas to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
        /** @description Opaque pagination token to go to next page based on previous query.
         *      */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The schemas list was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSchemasResponse'];
        };
      };
    };
  };
  createSchema: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateSchema'];
      };
    };
    responses: {
      /** @description The new schema was successfully created. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaInfo'];
        };
      };
    };
  };
  getSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the schema. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The schema was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaInfo'];
        };
      };
    };
  };
  deleteSchema: {
    parameters: {
      query?: {
        /** @description Force deletion even if the catalog is not empty. */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description Full name of the schema. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The schema was successfully deleted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  updateSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the schema. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateSchema'];
      };
    };
    responses: {
      /** @description The schema was successfully updated. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaInfo'];
        };
      };
    };
  };
  listTables: {
    parameters: {
      query: {
        /** @description Name of parent catalog for tables of interest. */
        catalog_name: string;
        /** @description Parent schema of tables. */
        schema_name: string;
        /** @description Maximum number of tables to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
        /** @description Opaque token to send for the next page of results (pagination). */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tables list was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListTablesResponse'];
        };
      };
    };
  };
  createTable: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateTable'];
      };
    };
    responses: {
      /** @description The new external table was successfully created. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TableInfo'];
        };
      };
    };
  };
  getTable: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the table. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The table was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TableInfo'];
        };
      };
    };
  };
  deleteTable: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the table. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The table was successfully deleted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  listVolumes: {
    parameters: {
      query: {
        /** @description The identifier of the catalog */
        catalog_name: string;
        /** @description The identifier of the schema */
        schema_name: string;
        /** @description Maximum number of volumes to return (page length).
         *
         *     If not set, the page length is set to a server configured value.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *
         *     Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.
         *
         *      */
        max_results?: number;
        /** @description Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination). */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The volume list was successfully retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVolumesResponseContent'];
        };
      };
    };
  };
  createVolume: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateVolumeRequestContent'];
      };
    };
    responses: {
      /** @description Successfully created the volume */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VolumeInfo'];
        };
      };
    };
  };
  getVolume: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The three-level (fully qualified) name of the volume */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved the properties of the volume */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VolumeInfo'];
        };
      };
    };
  };
  deleteVolume: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The three-level (fully qualified) name of the volume */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully deleted the volume */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  updateVolume: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The three-level (fully qualified) name of the volume */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateVolumeRequestContent'];
      };
    };
    responses: {
      /** @description Successfully updated the properties of the volume */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VolumeInfo'];
        };
      };
    };
  };
  generateTemporaryModelVersionCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['GenerateTemporaryModelVersionCredential'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TemporaryCredentials'];
        };
      };
    };
  };
  generateTemporaryTableCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['GenerateTemporaryTableCredential'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TemporaryCredentials'];
        };
      };
    };
  };
  generateTemporaryVolumeCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['GenerateTemporaryVolumeCredential'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TemporaryCredentials'];
        };
      };
    };
  };
  listFunctions: {
    parameters: {
      query: {
        /** @description Name of parent catalog for functions of interest. */
        catalog_name: string;
        /** @description Parent schema of functions. */
        schema_name: string;
        /** @description Maximum number of functions to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
        /** @description Opaque pagination token to go to next page based on previous query. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The function list was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListFunctionsResponse'];
        };
      };
    };
  };
  createFunction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateFunctionRequest'];
      };
    };
    responses: {
      /** @description The new function was successfully created. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FunctionInfo'];
        };
      };
    };
  };
  getFunction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The function was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FunctionInfo'];
        };
      };
    };
  };
  deleteFunction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__). */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The function was successfully deleted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  listRegisteredModels: {
    parameters: {
      query?: {
        /** @description Name of parent catalog for models of interest. */
        catalog_name?: string;
        /** @description Name of parent schema for models of interest. */
        schema_name?: string;
        /** @description Maximum number of models to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
        /** @description Opaque token to send for the next page of results (pagination). */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The models list was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRegisteredModelsResponse'];
        };
      };
    };
  };
  createRegisteredModel: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateRegisteredModel'];
      };
    };
    responses: {
      /** @description The new registered model was successfully created. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisteredModelInfo'];
        };
      };
    };
  };
  getRegisteredModel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The registered model was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisteredModelInfo'];
        };
      };
    };
  };
  deleteRegisteredModel: {
    parameters: {
      query?: {
        /** @description Force deletion even if the registered model still has model versions. */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The registered model was successfully deleted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  updateRegisteredModel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateRegisteredModel'];
      };
    };
    responses: {
      /** @description The registered model was successfully updated. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisteredModelInfo'];
        };
      };
    };
  };
  createModelVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateModelVersion'];
      };
    };
    responses: {
      /** @description The new model version was successfully created. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ModelVersionInfo'];
        };
      };
    };
  };
  listModelVersions: {
    parameters: {
      query?: {
        /** @description Maximum number of model versions to return.
         *     - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
         *     - when set to 0, the page length is set to a server configured value;
         *     - when set to a value less than 0, an invalid parameter error is returned;
         *      */
        max_results?: number;
        /** @description Opaque token to send for the next page of results (pagination). */
        page_token?: string;
      };
      header?: never;
      path: {
        /** @description Full name of the registered model. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The model versions list was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListModelVersionsResponse'];
        };
      };
    };
  };
  getModelVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
        /** @description Version number of the model version. */
        version: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The model version was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ModelVersionInfo'];
        };
      };
    };
  };
  deleteModelVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
        /** @description Version number of the model version. */
        version: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The model version was successfully deleted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
    };
  };
  updateModelVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
        /** @description Version number of the model version. */
        version: number;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateModelVersion'];
      };
    };
    responses: {
      /** @description The model version was successfully updated. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ModelVersionInfo'];
        };
      };
    };
  };
  finalizeModelVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Full name of the model. */
        full_name: string;
        /** @description Version number of the model version. */
        version: number;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['FinalizeModelVersion'];
      };
    };
    responses: {
      /** @description The model version was successfully finalized. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ModelVersionInfo'];
        };
      };
    };
  };
  generateTemporaryPathCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['GenerateTemporaryPathCredential'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TemporaryCredentials'];
        };
      };
    };
  };
  get: {
    parameters: {
      query?: {
        /** @description If provided, only the permissions for the specified principal (user or group) are returned.
         *      */
        principal?: string;
      };
      header?: never;
      path: {
        /** @description Type of securable. */
        securable_type: components['schemas']['SecurableType'];
        /** @description Full name of securable. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The permissions list for securable was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PermissionsList'];
        };
      };
    };
  };
  update: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Type of securable. */
        securable_type: components['schemas']['SecurableType'];
        /** @description Full name of securable. */
        full_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdatePermissions'];
      };
    };
    responses: {
      /** @description The permissions list for securable was successfully updated. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PermissionsList'];
        };
      };
    };
  };
  summary: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The metastore summary was successfully retrieved. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetMetastoreSummaryResponse'];
        };
      };
    };
  };
}
export enum VolumeType {
  MANAGED = 'MANAGED',
  EXTERNAL = 'EXTERNAL',
}
export enum ColumnTypeName {
  BOOLEAN = 'BOOLEAN',
  BYTE = 'BYTE',
  SHORT = 'SHORT',
  INT = 'INT',
  LONG = 'LONG',
  FLOAT = 'FLOAT',
  DOUBLE = 'DOUBLE',
  DATE = 'DATE',
  TIMESTAMP = 'TIMESTAMP',
  TIMESTAMP_NTZ = 'TIMESTAMP_NTZ',
  STRING = 'STRING',
  BINARY = 'BINARY',
  DECIMAL = 'DECIMAL',
  INTERVAL = 'INTERVAL',
  ARRAY = 'ARRAY',
  STRUCT = 'STRUCT',
  MAP = 'MAP',
  CHAR = 'CHAR',
  NULL = 'NULL',
  USER_DEFINED_TYPE = 'USER_DEFINED_TYPE',
  TABLE_TYPE = 'TABLE_TYPE',
}
export enum TableType {
  MANAGED = 'MANAGED',
  EXTERNAL = 'EXTERNAL',
}
export enum DataSourceFormat {
  DELTA = 'DELTA',
  CSV = 'CSV',
  JSON = 'JSON',
  AVRO = 'AVRO',
  PARQUET = 'PARQUET',
  ORC = 'ORC',
  TEXT = 'TEXT',
}
export enum FunctionParameterType {
  PARAM = 'PARAM',
  COLUMN = 'COLUMN',
}
export enum FunctionParameterMode {
  IN = 'IN',
}
export enum CreateFunctionRoutine_body {
  SQL = 'SQL',
  EXTERNAL = 'EXTERNAL',
}
export enum CreateFunctionParameter_style {
  S = 'S',
}
export enum CreateFunctionSql_data_access {
  CONTAINS_SQL = 'CONTAINS_SQL',
  READS_SQL_DATA = 'READS_SQL_DATA',
  NO_SQL = 'NO_SQL',
}
export enum CreateFunctionSecurity_type {
  DEFINER = 'DEFINER',
}
export enum FunctionInfoRoutine_body {
  SQL = 'SQL',
  EXTERNAL = 'EXTERNAL',
}
export enum FunctionInfoParameter_style {
  S = 'S',
}
export enum FunctionInfoSql_data_access {
  CONTAINS_SQL = 'CONTAINS_SQL',
  READS_SQL_DATA = 'READS_SQL_DATA',
  NO_SQL = 'NO_SQL',
}
export enum FunctionInfoSecurity_type {
  DEFINER = 'DEFINER',
}
export enum ModelVersionOperation {
  UNKNOWN_MODEL_VERSION_OPERATION = 'UNKNOWN_MODEL_VERSION_OPERATION',
  READ_MODEL_VERSION = 'READ_MODEL_VERSION',
  READ_WRITE_MODEL_VERSION = 'READ_WRITE_MODEL_VERSION',
}
export enum TableOperation {
  UNKNOWN_TABLE_OPERATION = 'UNKNOWN_TABLE_OPERATION',
  READ = 'READ',
  READ_WRITE = 'READ_WRITE',
}
export enum VolumeOperation {
  UNKNOWN_VOLUME_OPERATION = 'UNKNOWN_VOLUME_OPERATION',
  READ_VOLUME = 'READ_VOLUME',
  WRITE_VOLUME = 'WRITE_VOLUME',
}
export enum ModelVersionStatus {
  MODEL_VERSION_STATUS_UNKNOWN = 'MODEL_VERSION_STATUS_UNKNOWN',
  PENDING_REGISTRATION = 'PENDING_REGISTRATION',
  FAILED_REGISTRATION = 'FAILED_REGISTRATION',
  READY = 'READY',
}
export enum PathOperation {
  UNKNOWN_PATH_OPERATION = 'UNKNOWN_PATH_OPERATION',
  PATH_READ = 'PATH_READ',
  PATH_READ_WRITE = 'PATH_READ_WRITE',
  PATH_CREATE_TABLE = 'PATH_CREATE_TABLE',
}
export enum PrincipalType {
  USER = 'USER',
  GROUP = 'GROUP',
}
export enum SecurableType {
  metastore = 'metastore',
  catalog = 'catalog',
  schema = 'schema',
  table = 'table',
  function = 'function',
  volume = 'volume',
  registered_model = 'registered_model',
}
export enum Privilege {
  CREATE_CATALOG = 'CREATE CATALOG',
  USE_CATALOG = 'USE CATALOG',
  CREATE_SCHEMA = 'CREATE SCHEMA',
  USE_SCHEMA = 'USE SCHEMA',
  CREATE_TABLE = 'CREATE TABLE',
  SELECT = 'SELECT',
  MODIFY = 'MODIFY',
  CREATE_FUNCTION = 'CREATE FUNCTION',
  EXECUTE = 'EXECUTE',
  CREATE_VOLUME = 'CREATE VOLUME',
  READ_VOLUME = 'READ VOLUME',
  CREATE_MODEL = 'CREATE MODEL',
}
